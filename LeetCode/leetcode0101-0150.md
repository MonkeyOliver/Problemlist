# leetcode101-150

## 0101

    class Solution {
    public:
        bool isSymmetric(TreeNode* root) {
            if(!root)return true;
            queue<TreeNode*>q;
            q.push(root->left), q.push(root->right);
            while(!q.empty()){
                TreeNode*l = q.front(); q.pop();
                TreeNode*r = q.front(); q.pop();
                if (!l && r) return false;
                if (l && !r) return false;
                if(l && r){
                    if(l->val != r->val)return false;
                    q.push(l->left), q.push(r->right);
                    q.push(l->right), q.push(r->left);
                }
            }
            return true;
        }
    };

## 0102

    class Solution {
    public:
        vector<int>vs[1010];
        void dfs(TreeNode*cur, int cnt){
            vs[cnt].push_back(cur->val);
            if(cur->left)dfs(cur->left, cnt + 1);
            if(cur->right)dfs(cur->right, cnt + 1);
        }
        vector<vector<int>> levelOrder(TreeNode* root) {
            vector<vector<int>>ans;
            if(!root)return ans;
            dfs(root, 1);
            int cnt = 1;
            while(!vs[cnt].empty())ans.push_back(vs[cnt++]);
            return ans;
        }
    };

## 0103

    class Solution {
    public:
        vector<int>vs[1010];
        void dfs(TreeNode*cur, int cnt){
            vs[cnt].push_back(cur->val);
            if(cur->left)dfs(cur->left, cnt + 1);
            if(cur->right)dfs(cur->right, cnt + 1);
        }
        vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
            vector<vector<int>>ans;
            if(!root)return ans;
            dfs(root, 1);
            int cnt = 1;
            while(!vs[cnt].empty()){
                if(cnt%2)ans.push_back(vs[cnt]);
                else {
                    reverse(vs[cnt].begin(), vs[cnt].end());
                    ans.push_back(vs[cnt]);
                }
                cnt++;
            }
            return ans;
        }
    };

## 0104

    class Solution {
    public:
        int ans = 0;
        void dfs(TreeNode*cur, int cnt){
            ans = max(ans, cnt);
            if(cur->left)dfs(cur->left, cnt + 1);
            if(cur->right)dfs(cur->right, cnt + 1);
        }
        int maxDepth(TreeNode* root) {
            if(!root)return 0;
            dfs(root, 1);
            return ans;
        }
    };
