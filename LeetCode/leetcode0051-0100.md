# leetcode51-100

## 0053

    class Solution {
    public:
        int maxSubArray(vector<int>& nums) {
            long long sum = -10000000000, maxsum = 0;
            for (int i = 0; i < nums.size(); i++) {
                if (maxsum < 0) maxsum = nums[i];
                else maxsum += nums[i]; 
                sum = max(sum, maxsum);
            }
            return sum;
        }
    };

## 0054

    class Solution {
    public:
        vector<int> spiralOrder(vector<vector<int>>& matrix) {
            vector<int> ans;
            if(matrix.empty())return ans;
            int n = matrix.size(), m = matrix[0].size(), i = 0, j = 0;
            int endi = n - 1, endj = m - 1, si = 0, sj = 0;
            if(n==1)return matrix[0];
            if(m==1){
                while(i<=endi)ans.push_back(matrix[i++][j]);
                return ans;
            }
            while (1) {
                if (endi == si && endj == sj) { ans.push_back(matrix[si][sj]); return ans; }
                while (j != endj) {ans.push_back(matrix[i][j++]);if (ans.size() == n * m) return ans;}
                while (i != endi) {ans.push_back(matrix[i++][j]);if (ans.size() == n * m) return ans;}
                while (j != sj) {ans.push_back(matrix[i][j--]);if (ans.size() == n * m) return ans;}
                while (i != si) {ans.push_back(matrix[i--][j]);if (ans.size() == n * m) return ans;}
                if (ans.size() == n * m) return ans;
                endi--, endj--, si++, sj++;
                i = si, j = sj;
            }
        }
    };

## 0055

    int vis[100010];
    class Solution {
    public:
        bool bfs(vector<int>nums) {
            int n = nums.size();
            for(int i=0;i<=n;i++)vis[i]=0;
            queue<pair<int, int>>q;
            q.push(make_pair(nums[0], 0));
            vis[0] = 1;
            while (!q.empty()) {
                pair<int, int> cur = q.front();
                q.pop();
                for (int i = cur.second; i <= cur.first + cur.second; i++) {
                    if (!vis[i] && i < n) {
                        vis[i] = 1;
                        q.push(make_pair(nums[i], i));
                        if (i == n - 1)return true;
                    }
                }
            }
            return false;
        }
        bool canJump(vector<int>& nums) {
            if(nums.size()==1)return true;
            else return bfs(nums);
        }
    };

## 0056

    class Solution {
    public:
        vector<vector<int>> merge(vector<vector<int>>& intervals) {
            vector<vector<int>>ans;
            if (intervals.empty())return ans;
            else if (intervals.size() == 1)return intervals;
            sort(intervals.begin(), intervals.end(), [](vector<int>&a, vector<int>&b) {return a[0] < b[0]; });
            int i;
            for (i = 1; i < intervals.size(); i++) {
                vector<int>&pre = intervals[i - 1], &cur = intervals[i];
                if ((cur[0] >= pre[0] && cur[0] <= pre[1]) || (cur[1] <= pre[1])) { cur[0] = min(cur[0], pre[0]); cur[1] = max(cur[1], pre[1]); }
                else ans.push_back(pre);
            }
            --i;
            if (ans.empty())ans.push_back(intervals[0]);
            vector<int>last = intervals[i], &ans_last = ans[ans.size() - 1];
            if ((last[0] >= ans_last[0] && last[0] <= ans_last[1]) || (last[1] <= ans_last[1])) { ans_last[0] = min(last[0], ans_last[0]); ans_last[1] = max(last[1], ans_last[1]); }
            else ans.push_back(last);
            return ans;
        }
    };

## 0058

    class Solution {
    public:
        int lengthOfLastWord(string s) {
            int cnt = 0;
            for (int i = s.size() - 1; i >= 0; i--) {
                if (s[i] != ' ') cnt++;
                else {
                    if (!cnt)continue;
                    else break;
                }
            }
            return cnt;
        }
    };

## 0059

    class Solution {
    public:
        vector<vector<int>> generateMatrix(int n) {
            vector<vector<int>>ans;
            vector<int>tmp;
            if (!n)return ans;
            else if (n == 1) { tmp.push_back(1); ans.push_back(tmp); return ans; }
            for (int i = 0; i < n; i++)tmp.push_back(0);
            for (int i = 0; i < n; i++)ans.push_back(tmp);
            int num = 1, i = 0, j = 0, sti = 0, stj = 0, endi = n - 1, endj = n - 1;
            while (num < n*n) {
                while (i == sti && j != endj)ans[i][j++] = num++;
                while (i != endi && j == endj)ans[i++][j] = num++;
                while (i == endi && j != stj)ans[i][j--] = num++;
                while (i != sti && j == stj)ans[i--][j] = num++;
                endi--, endj--, sti++, stj++;
                i = sti, j = stj;
                if (endi == sti && endj == stj)ans[endi][endj] = num;
            }
            return ans;
        }
    };

## 0060

    class Solution {
    public:
        string getPermutation(int n, int k) {
            char ans[10];
            int cnt = 0;
            for (int i = 1; i <= n; i++)ans[cnt++] = ('0' + i);
            ans[cnt] = '\0';
            while (--k)next_permutation(ans, ans + n);
            return ans;
        }
    };

## 0061

    class Solution {
    public:
        ListNode* rotateRight(ListNode* head, int k) {
            int cnt = 1;
            ListNode*h = head;
            if(h == nullptr)return head;//这样例就nm离谱
            while(h->next)h = h->next, cnt++;
            h->next = head;
            k %= cnt;
            cnt -= k;
            h = head;
            if(!cnt)return head;
            while(cnt > 1){
                h = h->next;
                cnt--;
            }
            ListNode*new_h = h->next;
            h->next = nullptr;
            return new_h;
        }
    };

## 0062

    class Solution {
    public:
        int uniquePaths(int m, int n) {
            int dp[110][110];
            for (int i = 0; i < m; i++)dp[i][0] = 1;
            for (int i = 0; i < n; i++)dp[0][i] = 1;
            for (int i = 1; i < m; i++)
                for (int j = 1; j < n; j++)
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            return dp[m - 1][n - 1];
        }
    };

## 0063

    class Solution {
    public:
        int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
            if(obstacleGrid.empty())return 0;
            long dp[110][110];
            int m=obstacleGrid.size(),n=obstacleGrid[0].size();
            memset(dp,0,sizeof(dp));
            if (obstacleGrid[m-1][n-1])return 0;
            dp[0][0]=!obstacleGrid[0][0]?1:0;
            for (int i = 1; i < m; i++)dp[i][0] = (dp[i - 1][0] && !obstacleGrid[i][0]) ? 1 : 0;
            for (int i = 1; i < n; i++)dp[0][i] = (dp[0][i - 1] && !obstacleGrid[0][i]) ? 1 : 0;
            for (int i = 1; i < m; i++)
                for (int j = 1; j < n; j++)
                    dp[i][j] = !obstacleGrid[i][j]?dp[i - 1][j] + dp[i][j - 1]:0;
            return dp[m - 1][n - 1];
        }
    };

## 0064

    class Solution {
    public:
        int minPathSum(vector<vector<int>>& grid) {
            if (grid.empty())return 0;
            int dp[210][210], m = grid.size(), n = grid[0].size();
            memset(dp, 0x4f4f4f4f, sizeof(dp));
            dp[0][0] = grid[0][0];
            for (int i = 1; i < m; i++)dp[i][0] = dp[i - 1][0] + grid[i][0];
            for (int i = 1; i < n; i++)dp[0][i] = dp[0][i - 1] + grid[0][i];
            for (int i = 1; i < m; i++)
                for (int j = 1; j < n; j++)
                    dp[i][j] = min(dp[i - 1][j] + grid[i][j], dp[i][j - 1] + grid[i][j]);
            return dp[m - 1][n - 1];
        }
    };

## 0066

    class Solution {
    public:
        vector<int> plusOne(vector<int>& digits) {
            if (digits[digits.size() - 1] + 1 == 10) {
                digits[digits.size() - 1] = 0;
                for (int i = digits.size() - 2; i >= 0; i--) {
                    digits[i]++;
                    if (digits[i] == 10)digits[i] = 0;
                    else break;
                }
                if (!digits[0])digits.insert(digits.begin(), 1);
            }
            else digits[digits.size() - 1]++;
            return digits;
        }
    };

## 0067

    class Solution:
        def addBinary(self, a: str, b: str) -> str:
            return str(bin(int(a,2)+int(b,2)))[2:]

## 0069

    class Solution {
    public:
        int mySqrt(int x) {
            return sqrt(x);
        }
    };

## 0070

    class Solution {
    public:
        int climbStairs(int n) {
            long long a = 0, b = 1;
            while (n--) {
                long long tmp = b;
                b += a;
                a = tmp;
            }
            return b;
        }
    };

## 0073

    class Solution {
    public:
        void setZeroes(vector<vector<int>>& matrix) {
            int n = matrix.size(), m = matrix[0].size();
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (!matrix[i][j]) {
                    int tmpi = i, tmpj = j;
                    while (tmpi >= 0 && tmpi <= i)if (matrix[tmpi][j])matrix[tmpi--][j] = -1e4; else tmpi--;
                    tmpi = i;
                    while (tmpi < n && tmpi >= i)if (matrix[tmpi][j])matrix[tmpi++][j] = -1e4; else tmpi++;
                    while (tmpj >= 0 && tmpj <= j)if (matrix[i][tmpj])matrix[i][tmpj--] = -1e4; else tmpj--;
                    tmpj = j;
                    while (tmpj < m && tmpj >= j)if (matrix[i][tmpj])matrix[i][tmpj++] = -1e4; else tmpj++;
                    }
                }
            }
            for (int i = 0; i < n; i++)
                for (int j = 0; j < m; j++)
                    if (matrix[i][j] == -1e4)matrix[i][j] = 0;
        }
    };

## 0074

    bool binary_s(vector<int>::iterator b,vector<int>::iterator e,int t){
        auto l = b, r = e;
        while (l != r) {
            auto m = l + (r - l) / 2;
            if (*m == t)return true;
            else if (*m > t)r = m;
            else l = m + 1;
        }
        return false;
    }

    class Solution {
    public:
        bool searchMatrix(vector<vector<int>>& matrix, int target) {
            if(matrix.empty()||matrix[0].empty())return false;
            int n = matrix.size();
            for (int i = 0; i < n; i++) {
                if (matrix[i][0] < target) {
                    if (binary_s(matrix[i].begin(), matrix[i].end(), target))return true;
                    else continue;
                }
                else if(matrix[i][0]==target)return true;
                else return false;
            }
            return false;
        }
    };

## 0075

    class Solution {
    public:
        void sortColors(vector<int>& nums) {
            int col[3];
            for(auto i:nums)col[i]++;
            for(auto&i:nums){
                if(col[0]){i=0,col[0]--;}
                else if(col[1]){i=1;col[1]--;}
                else if(col[2]){i=2;col[2]--;}
            }
        }
    };

## 0077

    class Solution {
    public:
        vector<vector<int>> combine(int n, int k) {
            deque<vector<int>>pipe;
            vector<vector<int>>ans;
            for (int i = 1; i <= n; i++) {
                vector<int>t{ i };
                pipe.push_back(t);
            }
            while (1) {
                vector<int>tmp = pipe.front();
                if (tmp.size() == k)break;
                else {
                    pipe.pop_front();
                    int t = *(--tmp.end());
                    for (int i = t + 1; i <= n; i++) {
                        vector<int>newtmp = tmp;
                        newtmp.push_back(i);
                        pipe.push_back(newtmp);
                    }
                }
            }
            while (!pipe.empty()) {
                ans.push_back(pipe.front());
                pipe.pop_front();
            }
            return ans;
        }
    };

## 0078

    class Solution {
    public:
        vector<vector<int>> subsets(vector<int>& nums) {
            vector<vector<int>>ans={{}};
            vector<int>tmp;
            for(auto num:nums){
                int n=ans.size();
                for(int i = 0;i < n;i++){
                    ans.push_back(ans[i]);
                    ans.back().push_back(num);
                }
            }
            return ans;
        }
    };

## 0079

    class Solution {
    public:

        int dx[4] = { 0,0,1,-1 };
        int dy[4] = { 1,-1,0,0 };
        set<pair<int, int>>st;

        bool dfs(vector<vector<char>>& board, string&word, int x, int y, int n, int m, char c, int pos) {
            if (c != word[pos])return false;
            else if (pos == word.size() - 1 && c == word[pos])return true;        
            else {
                for (int i = 0; i < 4; i++) {
                    int tmpx = x + dx[i], tmpy = y + dy[i];
                    if (tmpx >= 0 && tmpx < n&&tmpy >= 0 && tmpy < m&&st.find({ tmpx,tmpy }) == st.end()) {
                        st.insert({ tmpx,tmpy });
                        if (dfs(board, word, tmpx, tmpy, n, m, board[tmpx][tmpy], pos + 1))return true;
                        st.erase({ tmpx,tmpy });
                    }
                }
                return false;
            }
        }

        bool exist(vector<vector<char>>& board, string word) {
            char s = word[0];
            int n = board.size(), m = board[0].size();
            for (int i = 0; i < n; i++)
                for (int j = 0; j < m; j++)
                    if (board[i][j] == s) {
                        st.insert({ i,j });
                        if (dfs(board, word, i, j, n, m, s, 0))return true;
                        st.erase({ i, j });
                    }
            return false;
        }
    };

## 0080

    class Solution {
    public:
        int removeDuplicates(vector<int>& nums) {
            int i = 0;
            for (int num : nums)if (i < 2 || num > nums[i-2])nums[i++] = num;
            return i;
        }
    };
